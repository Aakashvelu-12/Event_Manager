Event Manager:
	The event manager project is designed to allow multiple modules to register their interest in specific events, and when an event is triggered, all interested modules are notified. This implementation consists of four primary C files: event_manager.c, event_trigger.c, module.c, and main.c, each serving a specific role in handling event registration and execution.

Module.c:
	The module.c file defines five module functions: module_1, module_2, module_3, module_4, and module_5. Each function takes an event_id as a parameter and prints a message indicating that the respective module has responded to the given event.These functions serve as event handlers and are registered to specific events using add_module() in main.c. When an event is triggered, the corresponding module functions are executed, printing their respective messages along with the event ID.The module functions allow for modular event handling, making it possible to associate multiple modules with different events dynamically.

event_manger.c:
	IThe event_manager.c file manages event creation, initialization, module registration, and event triggering.
Event_t* event_head and Event_t* event_tail are pointers used to maintain a doubly linked list of events.
create_event(int event_id): Allocates memory for a new event, initializes its event_id, sets its function count to zero, and initializes the next and previous pointers.init(): Initializes the event manager by creating MAX_EVENTS events and linking them in a doubly linked list.add_module(int event_id, response module): Searches for the specified event and dynamically allocates or reallocates memory to store module function pointers, then registers the module function for the event.event_trigger(int event_id): Searches for the event in the list and invokes all registered module functions associated with it.This implementation enables efficient event handling, allowing multiple modules to be linked dynamically and triggered when an event occurs.

event_trigger.c:
	The event_trigger.c file acts as a simple interface that facilitates event triggering. It includes the necessary headers, event_trigger.h and event_manager.h, to access the event management functions. The primary function in this file, trigger(int event_id), serves as a wrapper around the event_trigger(event_id) function defined in event_manager.c. When trigger() is called in main.c, it delegates the event execution to event_trigger(), which ensures that all modules registered to the specified event are invoked. This design keeps the event triggering mechanism separate from the core event management logic, promoting modularity and maintainability in the system.

Main.c:
	The main.c file acts as the central control of the event-driven system. It starts by initializing the event manager using init(). The program then presents a menu to the user, allowing them to either register a module to an event or trigger an event.If the user selects option 1, they are prompted to enter an event ID and a module ID. The program displays the available events (Event 1 to Event 10) and modules (module_1 to module_5). Based on the module ID entered, the corresponding module function is registered to the selected event using add_module(event_id, module_function).If the user selects option 2, they are prompted to enter an event ID. The trigger(event_trigger_id) function is called, which in turn invokes trigger_event() in event_manager.c, executing all modules registered to that event.The program continues to loop until the user enters 0 to exit. This design allows dynamic linking of modules to events and event triggering in a structured manner.

Makefile:
	The Makefile automates the compilation of the event-driven system by defining rules for compiling individual source files and linking them into an executable. The CC variable specifies the GCC compiler, and CFLAGS includes the -Wall flag to enable all warnings for better code quality. The OBJFILES variable lists all object files needed for the final executable, named program.The all target ensures that the final executable is built by compiling all object files. Separate compilation rules are defined for module.o, event_manager.o, main.o, and event_trigger.o, ensuring that each source file is compiled only when necessary. The final executable is created by linking all object files. Additionally, a clean target is included to remove all compiled object files and the executable, making it easy to rebuild the project from scratch when needed.

Conclusion:
	In conclusion, this event-driven system efficiently manages event registration and triggering, allowing multiple modules to respond dynamically to specific events. The modular structure, with separate files for event management, event triggering, and module functions, enhances code maintainability and scalability. The use of a doubly linked list for event handling ensures efficient searching and registration of modules. Additionally, the Makefile automates compilation, ensuring proper dependency management and ease of rebuilding the project. This implementation demonstrates a structured approach to event handling in C, making it adaptable for more complex real-world applications.
